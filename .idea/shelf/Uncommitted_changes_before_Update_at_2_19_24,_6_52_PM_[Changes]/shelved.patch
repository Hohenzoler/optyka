Index: classes/light.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\nimport math\nfrom classes import gameobjects, fps\nimport time\nimport settingsSetup\nimport pygame.gfxdraw\nimport functions\n\nfrom bigtree import Node\n\n\nclass Ray:\n    def __init__(self, start_point, end_point, color):\n        self.start_point = start_point\n        self.end_point = end_point\n        self.color = color\n        self.active = True\n\nclass Light:\n    def __init__(self, game, points, color, angle, light_width, alpha=255):\n        # points is a list that represents endpoints of next lines building a stream of light\n        self.debug=False\n        self.prism_light=False\n        self.in_prism=False\n        self.in_mirror=False\n        self.main_light_slope=None\n        self.linear_function = None\n        self.starting_point=points[0]\n        self.points = points\n        self.game = game\n        self.color = color\n        self.angle = angle\n        self.light_width = light_width\n        self.layer = 0  # Assign a layer value to control rendering order\n        #self.game.objects.insert(-1, self)\n        self.colors=[]\n        self.RGB = RGB_Class(self.color[0], self.color[1], self.color[2])\n        self.colors.append(self.RGB.rgb)\n        self.x=self.points[0][0]\n        self.y=self.points[0][1]\n        self.count=1\n        self.get_r()\n        self.alpha = alpha\n        self.ignore_object = None\n\n        # print(self.r,self.linear_function)\n    def find_b(self,a,point):\n        return point[1]-a*point[0]\n\n    def render(self):\n        try:\n            ### For RTX Flashlight ###\n            if self.game.settings['HD_Flashlight'] == 'ON':\n                #### Original ####\n                # new_line_surface = pygame.Surface((self.game.width, self.game.height), pygame.SRCALPHA)\n                # new_line_surface.set_alpha(self.alpha)\n                for x in range(0, len(self.points) - 1):\n                    #### Beta testing stuff ####\n                    current_ray = Ray(self.points[x], self.points[x+1], self.colors[x])\n                    pointer = current_ray\n                    isAdded = False\n                    collisionless_layer = -1\n                    for surface_num, rays in self.game.surface_rays.items():\n                        collides = False\n                        # if rays == [] and len(self.game.surfaces) >0:\n                        #     self.game.surface_num -= 1\n                        #     #self.game.surface_rays.pop(surface_num)\n                        #     self.game.surfaces.pop()\n                        for ray in rays:\n                            if functions.do_lines_intersect(ray.start_point, ray.end_point, current_ray.start_point, current_ray.end_point):\n                                collides = True\n                            if current_ray.start_point == ray.start_point and current_ray.end_point == ray.end_point:\n                                isAdded = True\n                                if ray.active == False:\n                                    break\n                        if collides is False:\n                            collisionless_layer = surface_num\n                    if isAdded is False:\n                        if collisionless_layer != -1:\n                            self.game.surface_rays[collisionless_layer].append(current_ray)\n                        else:\n                            # More efficient way, but kinda glitchy\n                            self.game.surface_rays[max(self.game.surface_rays.keys())].append(current_ray)\n\n                            # Unfinished optimal method\n\n                            # self.game.surface_rays[max(self.game.surface_rays.keys()) + 1] = [current_ray]\n                            # surface = pygame.Surface((self.game.width, self.game.height), pygame.SRCALPHA)\n                            # surface.set_alpha(40)\n                            # self.game.surfaces.append(surface)\n                            # self.game.surface_num += 1\n                            # print(\"add\")\n\n                    #### Original ####\n\n                #     self.draw_thick_line(new_line_surface, int(self.points[x][0]), int(self.points[x][1]),\n                #                         int(self.points[x + 1][0]), int(self.points[x + 1][1]), self.colors[x], 5)\n                # self.game.screen.blit(new_line_surface, (0, 0))\n            ### For Simple Flashlight ###\n            else:\n                for x in range(0, len(self.points) - 1):\n                    self.draw_thick_line(self.game.screen, int(self.points[x][0]), int(self.points[x][1]),\n                                        int(self.points[x + 1][0]), int(self.points[x + 1][1]), self.colors[x], 5)\n\n        except (AttributeError, ValueError):\n            pass\n    #NON - RECURSIVE\n\n    def special_case_adjust(self):\n        if self.r==math.pi/2:\n            self.r=math.pi/2+0.00001\n        elif self.r==3*math.pi/2:\n            self.r=3*math.pi/2+0.00001\n        elif self.r==0:\n            self.r=0.00001\n        elif self.r==math.pi:\n            self.r=math.pi+0.00001\n    def trace_path2(self):\n        self.current_starting_point = self.starting_point\n        self.special_case_adjust()\n        self.mini_run=True\n        self.index=0\n        while self.mini_run:\n            if self.r < math.pi:\n                self.vertical = 'up'\n            else:\n                self.vertical = 'down'\n            if self.r < 3 / 2 * math.pi and self.r > 1 / 2 * math.pi:\n                self.horizontal = 'left'\n            else:\n                self.horizontal = 'right'\n            self.index+=1\n            self.linear_function = Linear_Function(math.tan(-self.r),\n                                                   self.find_b(math.tan(-self.r), self.current_starting_point))\n            if self.debug==True:\n                self.linear_function.draw(self.game)\n            try:\n                self.slope_before=self.current_slope\n            except:\n                self.slope_before=self.main_light_slope\n            self.current_point_before=self.current_starting_point\n            self.current_distance = None\n            self.current_point = None\n            self.current_slope = None\n            self.current_object=None\n            lenses = []\n            for object in self.game.objects:\n                if type(object) == gameobjects.Mirror or type(object)==gameobjects.ColoredGlass or type(object)==gameobjects.Prism:\n                    self.check_object(object) # gets the slope closest to the light and on the line of light and some other stuff\n                if type(object) == gameobjects.Lens:\n                    self.check_object(object)\n\n            # To do: fix bug causing only one lens to be analyzed\n\n            if self.current_slope == None:\n                self.border_stuff()\n            elif self.current_object_type=='mirror':\n                self.mirror_stuff()\n            elif self.current_object_type=='glass':\n                self.glass_stuff()\n            elif self.current_object_type=='lens':\n                self.lens_stuff(self.current_object)\n            elif self.current_object_type=='prism':\n                self.prism_stuff()\n\n\n\n            if self.index >= 100:\n                self.mini_run = False\n    def check_object(self,object):\n\n        if object == self.ignore_object:\n            return\n\n        object.get_slopes()\n\n        self.slopes = object.slopes\n        # print(slopes)\n        i = 0\n        for slope in self.slopes:\n\n            if slope == self.slope_before:\n                pass\n            else:\n                if (slope[0][0] - slope[1][0]) == 0:\n                    dx = 0.001\n                else:\n                    dx = (slope[0][0] - slope[1][0])\n                # r=math.atan((slope[0][0]-slope[1][0])/dy)\n\n                lf = Linear_Function((slope[0][1] - slope[1][1]) / dx,\n                                     self.find_b(((slope[0][1] - slope[1][1]) / dx), slope[0]))\n                # lf.draw(self.game)\n                x = lf.intercept(self.linear_function)\n                y = lf.calculate(x)\n                # lf.draw(self.game)\n                # self.linear_function.draw(self.game)\n                #\n                # pygame.draw.circle(self.game.screen,(255,0,0),(x,self.linear_function.calculate(x)),5)\n                # # pygame.draw.circle(self.game.screen, (0, 255, 0), slope[0], 5)\n                # # pygame.draw.circle(self.game.screen, (0, 255, 0), slope[1], 5)\n                # lf.draw(self.game)\n                point = (x, self.linear_function.calculate(x))\n                if x <= max(slope[0][0], slope[1][0]) + 1 and x >= min(slope[0][0], slope[1][0]) - 1:\n                    if y <= max(slope[0][1], slope[1][1]) + 1 and y >= min(slope[0][1], slope[1][1]) - 1:\n                        cases = 0\n                        if self.horizontal == 'right':\n                            if x >= self.current_starting_point[0]:\n                                cases += 1\n                                # print('aaaaaaa')\n                        else:\n                            if x <= self.current_starting_point[0]:\n                                cases += 1\n                        if self.vertical == 'up':\n                            if y <= self.current_starting_point[1]:\n                                cases += 1\n                        else:\n                            if y >= self.current_starting_point[1]:\n                                cases += 1\n                        # print(cases)\n                        if cases == 2:\n                            pygame.draw.line(self.game.screen, (0, 255, 0), slope[0], slope[1],\n                                             5)\n                            dist = abs(x - self.current_starting_point[0])\n                            if self.current_distance == None:\n                                self.current_distance = dist\n                                self.current_point = point\n                                self.current_slope = slope\n                                self.current_object = object\n\n                                if type(object) == gameobjects.Mirror:\n                                    self.current_object_type = 'mirror'\n\n                                elif type(object) == gameobjects.ColoredGlass:\n                                    self.current_object_type = 'glass'\n                                elif type(object) == gameobjects.Lens:\n                                    self.current_object_type = 'lens'\n                                elif type(object) == gameobjects.Prism:\n                                    self.current_object_type = 'prism'\n\n                            else:\n                                if dist < self.current_distance:\n                                    self.current_object = object\n                                    self.current_distance = dist\n                                    self.current_point = point\n                                    self.current_slope = slope\n\n                                    if type(object) == gameobjects.Mirror:\n                                        self.current_object_type = 'mirror'\n                                    elif type(object) == gameobjects.ColoredGlass:\n                                        self.current_object_type = 'glass'\n                                    elif type(object) == gameobjects.Lens:\n                                        self.current_object_type = 'lens'\n                                    elif type(object) == gameobjects.Prism:\n\n                                        self.current_object_type = 'prism'\n\n    def left_lens(self, lens):\n        for index, point in enumerate(lens.lens_points):\n            if functions.is_linear_function_passing_through_point(self.linear_function, point):\n                offset = 0\n                pygame.draw.line(self.game.screen, (255, 255, 80), lens.center1, (point[0] - offset, point[1] - offset))\n                slope1 = self.linear_function.a\n                slope2 = functions.calculate_slope(point[0], point[1], lens.center1[0], lens.center1[1])\n                intersect_angle = int(functions.calculate_intersection_angle(slope1, slope2))\n                ref_angle = math.asin(math.sin(math.radians(intersect_angle)) / lens.refraction_index)\n                # print(str(intersect_angle) + \" | \" + str(math.degrees(ref_angle)))\n                normal_angle = functions.calculate_angle(point[0], point[1], lens.center1[0], lens.center1[1])\n                # print(math.degrees(normal_angle))\n                if index < len(lens.lens_points) / 2:\n                    self.r = -normal_angle - ref_angle\n                else:\n                    self.r = -normal_angle + ref_angle\n\n                # print(math.degrees(self.r))\n\n                self.points.append(point)\n                self.colors.append(self.RGB.rgb)\n                self.current_starting_point = self.current_point #point\n                self.linear_function = Linear_Function(math.tan(-self.r),\n                                                       self.find_b(math.tan(-self.r),\n                                                                   self.current_starting_point))\n                self.linear_function.draw(self.game)\n                break\n    def right_lens(self, lens):\n        try:\n            for index, point in enumerate(lens.lens_points2):\n                if functions.is_linear_function_passing_through_point(self.linear_function, point):\n                    offset = 0\n                    pygame.draw.line(self.game.screen, (255, 255, 80), lens.center2,\n                                     (point[0] - offset, point[1] - offset))\n                    slope1 = self.linear_function.a\n                    slope2 = functions.calculate_slope(lens.center2[0], lens.center2[1], point[0], point[1])\n                    intersect_angle = int(functions.calculate_intersection_angle(slope2, slope1))\n                    temp = lens.refraction_index * math.sin(math.radians(intersect_angle))\n                    if temp > 1:\n                        temp -= 1\n                    ref_angle = math.asin(temp)\n                    print(str(intersect_angle) + \" | \" + str(math.degrees(ref_angle)))\n                    normal_angle = functions.calculate_angle(lens.center2[0], lens.center2[1], point[0], point[1])\n                    print(math.degrees(normal_angle))\n                    if index < len(lens.lens_points2) / 2:\n                        self.r = -normal_angle - ref_angle\n                    else:\n                        self.r = -normal_angle + ref_angle\n                    print(math.degrees(self.r))\n\n                    self.points.append(point)\n                    self.colors.append(self.RGB.rgb)\n                    self.current_starting_point = self.current_point #point\n                    self.linear_function = Linear_Function(math.tan(-self.r),\n                                                           self.find_b(math.tan(-self.r),\n                                                                       self.current_starting_point))\n                    self.linear_function.draw(self.game)\n                    break\n        except:\n            pass\n    def lens_stuff(self, lens):\n            if abs(self.angle) not in range(int(abs(lens.angle) + 90), int(abs(lens.angle) + 270)): # light shining from left to right # unfinished, bug when rotating >180deg\n                #print(abs(lens.angle))\n                self.left_lens(lens)\n                if lens.type == lens.CONVEX:\n                    self.right_lens(lens)\n\n            else:\n                print(\"rotated\")\n                self.right_lens(lens)\n                if lens.type == lens.CONVEX:\n                    self.left_lens(lens)\n            self.current_starting_point = self.current_point\n            self.calibrate_r2()\n\n\n\n    def glass_stuff(self):\n        self.points.append(self.current_point)\n        self.RGB.compare(RGB_Class(self.current_object.color[0],self.current_object.color[1],self.current_object.color[2]))\n        transmittance_factor = self.current_object.transmittance\n        self.RGB = RGB_Class(int(self.RGB.r * transmittance_factor), int(self.RGB.g * transmittance_factor),\n                       int(self.RGB.b * transmittance_factor))\n        self.colors.append(self.RGB.rgb)\n        #print(self.RGB.rgb)\n        self.current_starting_point = self.current_point\n\n        RGB2=RGB_Class(int(self.RGB.r * (1-transmittance_factor)), int(self.RGB.g * (1-transmittance_factor)),\n                       int(self.RGB.b * (1-transmittance_factor)))\n        r=self.r\n        self.reflect()\n        print(r,self.r)\n\n\n        self.r=r\n\n    def border_stuff(self):\n        self.points.append((self.current_point_before[0] + 10000 * math.cos(-self.r),\n                            self.current_point_before[1] + 10000 * math.sin(-self.r)))\n        self.colors.append(self.RGB.rgb)\n        self.mini_run = False\n\n    def reflect(self):\n\n\n        if (self.current_slope[0][0] - self.current_slope[1][0]) == 0:\n            self.slope_angle = math.pi / 2\n        else:\n\n            self.slope_angle = math.atan((self.current_slope[0][1] - self.current_slope[1][1]) / (\n                    self.current_slope[0][0] - self.current_slope[1][0]))\n            if self.current_slope[0][0] >= self.current_slope[1][0] and self.current_slope[0][1] > \\\n                    self.current_slope[1][1]:\n                self.slope_angle = math.pi - self.slope_angle\n            elif self.current_slope[1][0] >= self.current_slope[0][0] and self.current_slope[1][1] > \\\n                    self.current_slope[0][1]:\n                self.slope_angle = math.pi - self.slope_angle\n            else:\n                self.slope_angle = -self.slope_angle\n        self.r = 2 * self.slope_angle - self.r\n        self.calibrate_r2()\n    def mirror_stuff(self):\n        pygame.draw.line(self.game.screen, (0, 0, 255), self.current_slope[0], self.current_slope[1], 5)\n        self.points.append(self.current_point)\n        reflection_factor = self.current_object.reflection_factor\n        transmittance_factor = self.current_object.transmittance\n        self.RGB = RGB_Class(int(self.RGB.r * reflection_factor), int(self.RGB.g * reflection_factor),\n                       int(self.RGB.b * reflection_factor))\n\n        self.colors.append(self.RGB.rgb)\n\n        if not self.in_mirror:\n            self.angle = 0\n            self.make_mirror_light(self.angle, RGB_Class(int(self.RGB.r * transmittance_factor), int(self.RGB.g * transmittance_factor),\n                       int(self.RGB.b * transmittance_factor)).rgb)\n\n        self.reflect()\n\n\n        self.current_starting_point = self.current_point\n    def first_difract(self,prism):\n        n=prism.n\n        fi=prism.fi\n        self.r=fi/2+self.r+(round(prism.angle))/180*math.pi-math.asin(math.sin((fi/2+self.r))/n)\n\n    def second_difract(self,prism):\n        n = prism.n\n        fi = prism.fi\n        self.r=math.pi-math.asin(math.sin(1/2*prism.angle+fi-self.r)/n)\n    def prism_stuff(self):\n\n        pygame.draw.line(self.game.screen, (0, 0, 255), self.current_slope[0], self.current_slope[1], 5)\n        self.points.append(self.current_point)\n        reflection_factor = self.current_object.reflection_factor\n        self.RGB = RGB_Class(int(self.RGB.r * reflection_factor), int(self.RGB.g * reflection_factor),\n                             int(self.RGB.b * reflection_factor))\n\n        self.colors.append(self.RGB.rgb)\n        if self.in_prism:\n            self.first_difract(self.current_object)\n        else:\n            self.first_difract(self.current_object)\n\n        if not self.in_prism and self.prism_light==False:\n            angle=math.pi/18\n            da=math.pi/63\n            colors=[(194, 14, 26),(220, 145, 26),(247, 234, 59),(106, 169, 65),(69, 112, 180),(90, 40, 127),(128, 33, 125)]\n            red=self.RGB.rgb[0]/255\n            green=self.RGB.rgb[1]/255\n            blue=self.RGB.rgb[2] / 255\n            weights=[red,2/3*red+1/3*green,1/3*red+2/3*green,green,2/3*green+1/3*blue,1/3*green+2/3*blue,blue,2/3*blue+1/3*red,1/3*blue+2/3*red]\n            for x in range(0,7):\n                self.make_prism_light((colors[x][0]*weights[x],colors[x][1]*weights[x],colors[x][2]*weights[x]),angle)\n                angle-=da\n            self.mini_run = False\n\n\n        self.current_starting_point = self.current_point\n        if self.in_prism==True:\n            self.in_prism=False\n        else:\n            self.in_prism=True\n\n    def make_mirror_light(self, angle, color):\n        light1 = Light(self.game, [self.current_point], color, (self.r + angle) * 180 / math.pi,\n                       self.light_width)\n        light1.current_slope = self.current_slope\n        light1.in_mirror = True\n        light1.ignore_object = self.current_object\n        light1.debug = False\n        light1.trace_path2()\n        light1.render()\n\n    def make_prism_light(self,color,angle):\n        light1 = Light(self.game, [self.current_point], color, (self.r + angle) * 180 / math.pi,\n                         self.light_width)\n        light1.current_slope = self.current_slope\n        light1.in_prism = True\n        light1.prism_light=True\n        light1.debug=False\n        light1.trace_path2()\n        light1.render()\n\n\n\n\n    def calibrate_r2(self):\n        if self.r>2*math.pi:\n            self.r-=2*math.pi\n        if self.r<0:\n            self.r+=2*math.pi\n\n    def get_r(self):\n        self.r=self.angle/360*2*math.pi\n        if self.r>2*math.pi:\n            self.r-=2*math.pi\n        if self.r<0:\n            self.r+=2*math.pi\n\n    def draw_thick_line(self, surface, x1, y1, x2, y2, color, THICC):\n        dx = x2 - x1\n        dy = y2 - y1\n        if abs(dx) > abs(dy):\n            for offset in range(THICC):\n                pygame.gfxdraw.line(surface, x1, y1 + offset, x2, y2 + offset, color)\n        else:\n            for offset in range(THICC):\n                pygame.gfxdraw.line(surface, x1 + offset, y1, x2 + offset, y2, color)\n\n\n\n\n\n    def callibrate_r(self):\n        if self.r > 2*math.pi:\n            self.r-=2*math.pi\n    def trace_path(self, max_time_seconds=(1/fps.return_fps())):\n        self.points=[self.starting_point]\n\n        self.colors = []\n        self.RGB = RGB(self.color[0], self.color[1], self.color[2])\n        self.colors.append(self.RGB.rgb)\n        self.r=-self.angle/360*2*math.pi\n\n        self.vx = self.x\n        self.vy = self.y\n        self.trace=True\n        start_time = time.time()\n        while self.trace and (time.time() - start_time) < max_time_seconds:\n            # print(self.r)\n            self.callibrate_r()\n            self.forward()\n            self.update_vp()\n            self.border()\n            self.collision_check()\n    def border(self):\n        if self.vx<0 or self.vx>self.game.width or self.vy<0 or self.vy>self.game.height:\n            self.points.append((self.vx, self.vy))\n            self.trace=False\n    def bend(self,angle):\n        # self.r=2*math.pi-(math.pi+self.r-2*angle)\n        self.r = 2*angle-self.r+math.pi\n\n    def area(self,triangle):\n        p1,p2,p3=triangle\n\n        a=self.length(p1,p2)\n        b = self.length(p3, p2)\n        c = self.length(p1, p3)\n        s=(a+b+c)/2\n        return (s*(s-a)*(s-b)*(s-c))**(1/2)\n    def length(self,p1,p2):\n        return ((p1[0]-p2[0])**2+(p1[1]-p2[1])**2)**(1/2)\n    def find_angle2(self,object):\n        triangles=object.get_triangles()\n        i=0\n        for triangle in triangles:\n\n            area=self.area(triangle)\n            t1=(triangle[0],triangle[1],self.vp)\n            area1=self.area(t1)\n\n            t2 = (triangle[2], triangle[1], self.vp)\n            area2 = self.area(t2)\n\n            t3 = (triangle[0], triangle[2], self.vp)\n            area3 = self.area(t3)\n\n            sum=area1+area2+area3\n            if sum<=area+200:\n                pygame.draw.polygon(self.game.screen, (255, 255, 255), triangle)\n                # print(math.asin((triangle[1][0]-triangle[2][0])/self.length(triangle[1],triangle[2])))\n                return math.asin((triangle[1][0]-triangle[2][0])/self.length(triangle[1],triangle[2]))\n\n            i+=1\n        return self.find_angle(object)\n\n    def find_angle(self,object):\n        two_points=[]\n        two_points_distance=[]\n        for point in object.points:\n            if len(two_points)<2:\n                two_points.append(point)\n                two_points_distance.append(self.dist(self.vx,self.vy,point[0],point[1]))\n            else:\n                distance = self.dist(self.vx,self.vy,point[0],point[1])\n                if distance< two_points_distance[0]:\n                    two_points[0]=point\n                    two_points_distance[0]=distance\n                elif distance< two_points_distance[1]:\n                    two_points[1]=point\n                    two_points_distance[1]=distance\n\n        angle=math.asin((two_points[0][1] - two_points[1][1]) / self.dist(two_points[0][0], two_points[0][1], two_points[1][0],two_points[1][1]))\n        return angle\n    def two_points_angle(self,two_points):\n        return math.asin(\n            (two_points[0][1] - two_points[1][1]) / self.dist(two_points[0][0], two_points[0][1], two_points[1][0],\n                                                              two_points[1][1]))\n    def dist(self,x1,y1,x2,y2):\n        return ((x1-x2)**2 + (y1-y2)**2)**(1/2)\n    def update_vp(self):\n\n        self.vp = (self.vx, self.vy)  # vp - virtual pointer - a place where the light will come\n        self.vp_rect=pygame.Rect(self.vx, self.vy, 1, 1)\n        self.vp_polygon = [(self.vx, self.vy + 1), (self.vx + 1, self.vy+1), (self.vx + 1, self.vy), (self.vx, self.vy)]\n        #pygame.draw.polygon(self.game.screen, self.color, self.vp_polygon) # For visualizing hitbox\n    def forward(self):\n\n        is_mirror = False\n\n        for object in self.game.objects:\n            if type(object)==gameobjects.Mirror:\n                is_mirror = True\n        if is_mirror == False:\n            self.vx += 1000 * math.cos(self.r)\n            self.vy += 1000 * math.sin(self.r)\n        else:\n            self.vx += math.cos(self.r)\n            self.vy += math.sin(self.r)\n\n\n        # print(self.vx,self.vy)\n\n\nclass RGB_Class():\n    def __init__(self,r,g,b):\n        self.r=r\n        self.g=g\n        self.b=b\n        self.a = max(r, g, b)\n        self.rgb=(r,g,b, self.a)\n    def compare(self,RGB2):\n        if RGB2.r<self.r:\n            self.r=RGB2.r\n        if RGB2.g < self.g:\n            self.g = RGB2.g\n        if RGB2.b<self.b:\n            # print('aaa')\n            self.b=RGB2.b\n\n        self.update()\n\n    def update(self):\n        # print(self.b)\n        self.rgb=(self.r,self.g,self.b, self.a)\nclass Linear_Function:\n    def __init__(self,a,b):\n        self.a=a\n        self.b=b\n    def calculate(self,number):\n        return self.a*number+self.b\n    def intercept(self,linear_function):\n        if self.a==linear_function.a:\n            return -1\n        else:\n            return (self.b-linear_function.b)/(linear_function.a-self.a)\n    def __str__(self):\n        return f\" {self.a}*x + {self.b}\"\n    def draw(self,game):\n        pygame.draw.line(game.screen, (255, 255, 255), (0, self.calculate(0)),\n                         (1000, self.calculate(1000)), 2)\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/classes/light.py b/classes/light.py
--- a/classes/light.py	(revision fa2e26f95d9ee9d96527cdb76d5ed1ead7cd2ca2)
+++ b/classes/light.py	(date 1708365087380)
@@ -390,6 +390,8 @@
             self.angle = 0
             self.make_mirror_light(self.angle, RGB_Class(int(self.RGB.r * transmittance_factor), int(self.RGB.g * transmittance_factor),
                        int(self.RGB.b * transmittance_factor)).rgb)
+        else:
+            self.in_mirror = False
 
         self.reflect()
 
@@ -442,7 +444,6 @@
         light1 = Light(self.game, [self.current_point], color, (self.r + angle) * 180 / math.pi,
                        self.light_width)
         light1.current_slope = self.current_slope
-        light1.in_mirror = True
         light1.ignore_object = self.current_object
         light1.debug = False
         light1.trace_path2()
